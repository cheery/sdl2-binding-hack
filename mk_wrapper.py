from clang.cindex import *

header = """
# autogenerated by mk_wrapper.py - edit the mk_wrapper.py instead.
from ctypes import CDLL, c_char, c_ubyte, c_int, c_uint, c_long, c_ulong, c_short, c_ushort, c_void_p, c_char_p, c_float, c_double, POINTER, CFUNCTYPE, Structure, Union

lib = CDLL('libSDL2-2.0.so.0')

def DEFINE_PIXELFORMAT(type, order, layout, bits, bytes):
    return (
        (1 << 28) | ((type) << 24) |
        ((order) << 20) | ((layout) << 16) |
        ((bits) << 8) | ((bytes) << 0)
    )

SCANCODE_MASK = 1 << 30
def SCANCODE_TO_KEYCODE(X):
    return (X | SCANCODE_MASK)

""".strip()

sdl_api = set(name.strip() for name in open('sdl_api').readlines())
#sdl_api = set((
#    'SDL_Init',
#    'SDL_Quit',
#    'SDL_CreateWindow',
#    'SDL_DestroyWindow',
#    'SDL_Delay',
#))
sdl_found = set()

def main():
    Config.set_library_file('/usr/lib/llvm-3.3/lib/libclang.so.1')

    path = '/usr/include/SDL2/SDL.h'
    args = ['-D_Noreturn=__attribute__ ((__noreturn__))']

    index = Index.create()
    translation_unit = index.parse(path, args, options=0x5)

    print header
    translate(translation_unit.cursor)

    print "\n# not found: ", sdl_api - sdl_found

def translate(node, parent=None):
    if node.spelling in sdl_api:
        print_translation(node.spelling, node, parent)
        sdl_found.add(node.spelling)
    elif node.displayname in sdl_api:
        print_translation(node.displayname, node, parent)
        sdl_found.add(node.displayname)
    elif node.kind == CursorKind.ENUM_DECL:
        print_translation(node.spelling, node, parent)
    elif node.kind == CursorKind.MACRO_DEFINITION:
        print_translation(node.spelling, node, parent)
    for child in node.get_children():
        translate(child, node)

def print_translation(name, node, parent):
    if node.kind == CursorKind.FUNCTION_DECL:
        t = node.type
        print func_decl.format(
            name     = trim(name),
            cname    = name,
            restype  = translated_type(t.get_result()),
            argtypes = '[%s]' % ', '.join(
                translated_type(a)
                for a in t.argument_types()
            ),
        )
    elif node.kind == CursorKind.ENUM_DECL:
        translate_enumerations(node)
    elif node.kind == CursorKind.MACRO_DEFINITION:
        if name is None:
            return
        const = read_macro_constant(node)
        if const is not None:
            print "#{0} = {1}".format(name, const).replace('\n', '\n#')
    else:
        print "#{name}".format(name=name).replace('\n', '\n#')

func_decl = """
{name} = lib.{cname}
{name}.restype  = {restype}
{name}.argtypes = {argtypes} 
""".rstrip()

def translated_type(t):
    if t.kind in simpletypes:
        return simpletypes[t.kind]
    if t.kind == TypeKind.CONSTANTARRAY:
        elemtype = translated_type(t.get_array_element_type())
        sz = t.get_array_size()
        return '({0}*{1})'.format(elemtype, sz)
    if t.kind == TypeKind.TYPEDEF:
        return translate_typedef(t)
    if t.kind == TypeKind.ENUM:
        decl = t.get_declaration()
        basetype = TypeKind.INT
        for attr in decl.get_children():
            assert attr.type.kind == basetype
        translate_enumerations(decl)
        return simpletypes[basetype]
    if t.kind == TypeKind.POINTER:
        pointee = t.get_pointee()
        if pointee.kind == TypeKind.CHAR_S:
            return "c_char_p"
        if pointee.kind == TypeKind.VOID:
            return "c_void_p"
        if pointee.kind == TypeKind.UNEXPOSED:
            return "c_void_p"
        if pointee.kind == TypeKind.FUNCTIONPROTO:
            return "CFUNCTYPE({0}, {1})".format(
                translated_type(pointee.get_result()),
                ', '.join(
                    translated_type(a)
                    for a in pointee.argument_types()
                )
            )
        if pointee.kind == TypeKind.TYPEDEF and pointee.get_declaration().spelling == 'FILE':
            return "c_void_p"
        resp = "POINTER({0})".format(translated_type(pointee))
#        if resp == 'POINTER(FILE)':
#            raise Exception("weeird %r" % pointee.kind)
        return resp
    if t.kind == TypeKind.RECORD:
        decl = t.get_declaration()
        if decl.spelling:
            return translate_decl(decl, decl.spelling)
        else:
            return 'RECORD_UNKNOWN(%r)' % (decl.kind)
    return 'UNKNOWN(%r)' % t.kind


simpletypes = {
    TypeKind.CHAR_S: 'c_char',
    TypeKind.SHORT: 'c_short',
    TypeKind.INT:  'c_int',
    TypeKind.LONG: 'c_long',
    TypeKind.UCHAR: 'c_ubyte',
    TypeKind.USHORT: 'c_ushort',
    TypeKind.UINT: 'c_uint',
    TypeKind.ULONG: 'c_ulong',
    TypeKind.FLOAT: 'c_float',
    TypeKind.DOUBLE: 'c_double',
    TypeKind.VOID: 'None',
}

def translate_typedef(t):
    decl = t.get_declaration()
    name = trimCamel(decl.spelling)
#    if name == 'FILE':
#        raise Exception("weeird %r" % t.get_canonical().kind)
    if decl.spelling not in sdl_found:
        can = t.get_canonical()
        if can.kind == TypeKind.RECORD:
            decl = can.get_declaration()
            return translate_decl(decl, name)
        sdl_found.add(decl.spelling)
        print "\n{0} = {1}".format(name, translated_type(can))
    return name

def translate_decl(decl, name):
    if name == 'SDL_AudioCVT':
        name = 'AudioCVT'
    if name not in sdl_found:
        sdl_found.add(name)
        if name == 'AudioCVT':
            print 'AudioCVT = None'
        c_fields = []
        prefix = None
        for field in decl.get_children():
            if not field.spelling:
                prefix = field.type
            elif field.type.kind == TypeKind.UNEXPOSED:
                resp = 'UNEXPOSED_UNKNOWN'
                if prefix.kind == TypeKind.RECORD:
                    d = prefix.get_declaration()
                    resp = translate_decl(d, name + '_' + field.spelling)
                c_fields.append( "('{0}', {1})".format(
                    field.spelling, resp 
                ))
            else:
                c_fields.append( "('{0}', {1})".format(
                    field.spelling, translated_type(field.type)
                ))
                prefix = None
        print record_decl.format(
            name = trimCamel(name),
            inherit_from = {
                CursorKind.UNION_DECL:'Union',
                CursorKind.STRUCT_DECL:'Structure',
            }[decl.kind],
            fields = ',\n        '.join(c_fields),
        )
    return trimCamel(name)

record_decl = """
class {name}({inherit_from}):
    _fields_ = [
        {fields}
    ]
""".rstrip()

def translate_enumerations(decl):
    const = 0
    for attr in decl.get_children():
        for info in attr.get_children():
            if info.kind in (CursorKind.PAREN_EXPR, CursorKind.UNARY_OPERATOR):
                const = read_macro_constant(info)
            elif info.kind != CursorKind.UNEXPOSED_EXPR:
                assert info.kind in (CursorKind.CHARACTER_LITERAL, CursorKind.INTEGER_LITERAL), repr((info.kind, info.spelling, info.displayname))
        name = trimCamel(attr.spelling)
        if name not in sdl_found and not name.startswith('_'):
            sdl_found.add(name)
            print "{0} = {1}".format(name, const)
        if isinstance(const, (int, long)):
            const += 1

def read_macro_constant(node):
    extent = node.extent
    start, end = extent.start, extent.end
    if start.file is None:
        return
    with open(start.file.name) as fd:
        a = start.offset + len(node.displayname)
        b = end.offset
        data = fd.read()[a:b].strip()
        if data == '':
            return None
        if data[0] == '-' and data[1:].isdigit():
            return int(data)
        if data.isdigit():
            return int(data)
        if data.startswith('0x'):
            return int(data, 16)
        if data.startswith('"') and data.endswith('"'):
            return data[1:-1]
        return data.replace('SDL_', '')
        raise Exception("no interpretation found for %r" % data)

def trimCamel(name):
    if not name.startswith('SDL_'):
        assert name
        return name
    return name[4:]

def trim(name):
    if not name.startswith('SDL_'):
        assert name
        return name
    if any(ch in 'aoeuiAOEUI' for ch in name[4:7]):
        return name[4].lower() + name[5:]
    else:
        return name[4:]

if __name__=='__main__':
    main()

#import itertools
#
#functions = set()
#def sdl_func(spelling):
#    return spelling.startswith('SDL_') and spelling[:5].upper() == spelling[:5]
#
#
#
#def scan(node, parent=None):
#    if node.kind == CursorKind.FUNCTION_DECL and sdl_func(node.spelling):
#        functions.add(node.spelling)
#    if node.kind == CursorKind.MACRO_DEFINITION and node.displayname.startswith('SDL_'):
#        pass
#        #print node.displayname, read_macro_constant(node)
#    if node.kind == CursorKind.ENUM_CONSTANT_DECL and node.displayname.startswith('SDL_'):
#        print node.displayname, read_enum_constant(node, parent)
#    
##    print node.spelling, node.displayname, node.kind
#    for child in node.get_children():
#        scan(child, node)
##        print child.spelling, child.kind
#
